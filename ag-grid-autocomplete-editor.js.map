{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///external \"@ag-grid-community/core\"","webpack:///./autocompleter/autocomplete.ts","webpack:///./ag-grid-autocomplete-editor.ts"],"names":["root","factory","exports","module","require","define","amd","a","i","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","autocomplete","settings","selected","debounceTimer","doc","input","ownerDocument","document","container","createElement","containerStyle","style","userAgent","navigator","mobileFirefox","indexOf","debounceWaitMs","strict","autoselectfirst","onFreeTextSelect","keyUpEventName","items","inputValue","minLen","undefined","minLength","showOnFocus","keypressCounter","Error","clearDebounceTimer","clearTimeout","containerDisplayed","parentNode","clear","parent","removeChild","update","firstChild","render","item","currentValue","itemElement","textContent","label","renderGroup","groupName","groupDiv","fragment","createDocumentFragment","prevGroup","forEach","group","className","appendChild","div","addEventListener","ev","onSelect","preventDefault","stopPropagation","length","emptyMsg","empty","body","height","width","offsetWidth","inputRect","getBoundingClientRect","top","offsetHeight","maxHeight","defaultView","innerHeight","bottom","left","customize","updatePosition","elements","getElementsByClassName","element","previous","previousElementSibling","offsetTop","scrollTop","selectBottom","containerBottom","updateScroll","updateIfDisplayed","resizeEventHandler","scrollEventHandler","e","target","keyupEventHandler","keyCode","which","startFetch","keydownEventHandler","containerIsDisplayed","selectPrev","selectNext","freeTextSelect","focusEventHandler","trigger","savedKeypressCounter","val","setTimeout","fetch","blurEventHandler","activeElement","position","destroy","removeEventListener","focusAfterAttached","required","eInput","getGui","querySelector","currentItem","suppressKeyboardEvent","params","event","editing","getStartValue","keyPress","charPress","formatValue","init","this","stopEditing","defaultSettings","cellEditor","escapedValue","replace","regex","RegExp","fieldItem","innerHTML","match","addManagedListener","text","callback","getSelectData","toLowerCase","filter","cellStartedEdit","placeholder","AutocompleteSelectCellEditor","autocompleteParams","autocompleter","result","KeyboardEvent","handleTabEvent","colDef","gridOptionsWrapper","shiftKey","getApi","tabToPreviousCell","tabToNextCell","afterGuiAttached","focus","select","setSelectionRange","focusIn","focusOut","blur","getValue","isCancelAfterEnd","isCancelBeforeStart","isPopup","selectData","Array","isArray"],"mappings":"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","file":"ag-grid-autocomplete-editor.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@ag-grid-community/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@ag-grid-community/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"@ag-grid-community/core\")) : factory(root[\"@ag-grid-community/core\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"http://localhost:8080/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","/*\r\n * https://github.com/kraaden/autocomplete\r\n * Copyright (c) 2016 Denys Krasnoshchok\r\n * MIT License\r\n */\r\n\r\nexport const enum EventTrigger {\r\n    Keyboard = 0,\r\n    Focus = 1\r\n}\r\n\r\nexport interface AutocompleteItem {\r\n    label?: string;\r\n    group?: string;\r\n}\r\n\r\nexport interface AutocompleteSettings<T extends AutocompleteItem> {\r\n    input: HTMLInputElement;\r\n    render?: (item: T, currentValue: string) => HTMLDivElement | undefined;\r\n    renderGroup?: (name: string, currentValue: string) => HTMLDivElement | undefined;\r\n    className?: string;\r\n    minLength?: number;\r\n    emptyMsg?: string;\r\n    strict: boolean;\r\n    autoselectfirst: boolean;\r\n    onFreeTextSelect?: (item: T, input: HTMLInputElement) => void;\r\n    onSelect: (item: T | undefined, input: HTMLInputElement, event: KeyboardEvent | MouseEvent) => void;\r\n    /**\r\n     * Show autocomplete on focus event. Focus event will ignore the `minLength` property and will always call `fetch`.\r\n     */\r\n    showOnFocus?: boolean;\r\n    fetch: (text: string, update: (items: T[] | false) => void, trigger: EventTrigger) => void;\r\n    debounceWaitMs?: number;\r\n    /**\r\n     * Callback for additional autocomplete customization\r\n     * @param {HTMLInputElement} input - input box associated with autocomplete\r\n     * @param {ClientRect | DOMRect} inputRect - size of the input box and its position relative to the viewport\r\n     * @param {HTMLDivElement} container - container with suggestions\r\n     * @param {number} maxHeight - max height that can be used by autocomplete\r\n     */\r\n    customize?: (input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\r\n}\r\n\r\nexport interface AutocompleteResult {\r\n    destroy: () => void;\r\n}\r\n\r\nconst enum Keys {\r\n    Enter = 13,\r\n    Esc = 27,\r\n    Up = 38,\r\n    Down = 40,\r\n    Left = 37,\r\n    Right = 39,\r\n    Shift = 16,\r\n    Ctrl = 17,\r\n    Alt = 18,\r\n    CapsLock = 20,\r\n    WindowsKey = 91,\r\n    Tab = 9\r\n}\r\n\r\nexport default function autocomplete<T extends AutocompleteItem>(this: any, settings: AutocompleteSettings<T>): AutocompleteResult {\r\n\r\n    // just an alias to minimize JS file size\r\n    // use settings.input.ownerDocument if possible, to avoid iFrame scopes confusion\r\n    let doc = settings.input.ownerDocument || window.document;\r\n    const container: HTMLDivElement = doc.createElement(\"div\");\r\n    const containerStyle = container.style;\r\n    const userAgent = navigator.userAgent;\r\n    const mobileFirefox = userAgent.indexOf(\"Firefox\") !== -1 && userAgent.indexOf(\"Mobile\") !== -1;\r\n    const debounceWaitMs = settings.debounceWaitMs || 0;\r\n    const strict = settings.strict;\r\n    const autoselectfirst = settings.autoselectfirst;\r\n    const onFreeTextSelect = settings.onFreeTextSelect;\r\n\r\n    // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead\r\n    const keyUpEventName = mobileFirefox ? \"input\" : \"keyup\";\r\n\r\n    let items: T[] = [];\r\n    let inputValue = \"\";\r\n    const minLen = settings.minLength !== undefined ? settings.minLength : 2;\r\n    const showOnFocus = settings.showOnFocus;\r\n    let selected: T | undefined;\r\n    let keypressCounter = 0;\r\n    let debounceTimer: number | undefined;\r\n\r\n    if (!settings.input) {\r\n        throw new Error(\"input undefined\");\r\n    }\r\n\r\n    const input: HTMLInputElement = settings.input;\r\n\r\n    container.className = \"autocomplete \" + (settings.className || \"\");\r\n    containerStyle.position = \"fixed\";\r\n\r\n    /**\r\n     * Detach the container from DOM\r\n     */\r\n    function detach(): void {\r\n        const parent = container.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(container);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear debouncing timer if assigned\r\n     */\r\n    function clearDebounceTimer(): void {\r\n        if (debounceTimer) {\r\n            window.clearTimeout(debounceTimer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the container to DOM\r\n     */\r\n    function attach(): void {\r\n        doc = settings.input.ownerDocument || window.document;\r\n        if (!container.parentNode) {\r\n            doc.body.appendChild(container);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if container for autocomplete is displayed\r\n     */\r\n\r\n    function containerDisplayed(): boolean {\r\n        return !!container.parentNode;\r\n    }\r\n\r\n    /**\r\n     * Clear autocomplete state and hide container\r\n     */\r\n\r\n    function clear(): void {\r\n        keypressCounter++;\r\n        items = [];\r\n        inputValue = \"\";\r\n        selected = undefined;\r\n        detach();\r\n    }\r\n\r\n    /**\r\n     * Update autocomplete position\r\n     */\r\n    function updatePosition(): void {\r\n        if (!containerDisplayed()) {\r\n            return;\r\n        }\r\n\r\n        containerStyle.height = \"auto\";\r\n        containerStyle.width = input.offsetWidth + \"px\";\r\n\r\n        const inputRect = input.getBoundingClientRect();\r\n        const top = inputRect.top + input.offsetHeight;\r\n        let maxHeight = doc.defaultView!.innerHeight - top;\r\n\r\n        if (maxHeight < 0) {\r\n            maxHeight = 0;\r\n        }\r\n\r\n        containerStyle.top = top + \"px\";\r\n        containerStyle.bottom = \"\";\r\n        containerStyle.left = inputRect.left + \"px\";\r\n        containerStyle.maxHeight = maxHeight + \"px\";\r\n\r\n        if (settings.customize) {\r\n            settings.customize(input, inputRect, container, maxHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Redraw the autocomplete div element with suggestions\r\n     */\r\n\r\n    function update(): void {\r\n\r\n        // delete all children from autocomplete DOM container\r\n        while (container.firstChild) {\r\n            container.removeChild(container.firstChild);\r\n        }\r\n\r\n        // function for rendering autocomplete suggestions\r\n        // noinspection JSUnusedLocalSymbols\r\n        let render = function (item: T, currentValue: string): HTMLDivElement | undefined {\r\n            const itemElement = doc.createElement(\"div\");\r\n            itemElement.textContent = item.label || \"\";\r\n            return itemElement;\r\n        };\r\n        if (settings.render) {\r\n            render = settings.render;\r\n        }\r\n\r\n        // function to render autocomplete groups\r\n        // noinspection JSUnusedLocalSymbols\r\n        let renderGroup = function (groupName: string, currentValue: string): HTMLDivElement | undefined {\r\n            const groupDiv = doc.createElement(\"div\");\r\n            groupDiv.textContent = groupName;\r\n            return groupDiv;\r\n        };\r\n        if (settings.renderGroup) {\r\n            renderGroup = settings.renderGroup;\r\n        }\r\n\r\n        const fragment = doc.createDocumentFragment();\r\n        let prevGroup = \"#9?$\";\r\n\r\n        items.forEach(function (item: T): void {\r\n            if (item.group && item.group !== prevGroup) {\r\n                prevGroup = item.group;\r\n                const groupDiv = renderGroup(item.group, inputValue);\r\n                if (groupDiv) {\r\n                    groupDiv.className += \" group\";\r\n                    fragment.appendChild(groupDiv);\r\n                }\r\n            }\r\n            const div = render(item, inputValue);\r\n            if (div) {\r\n                div.addEventListener(\"click\", function (ev: MouseEvent): void {\r\n                    settings.onSelect(item, input, ev);\r\n                    clear();\r\n                    ev.preventDefault();\r\n                    ev.stopPropagation();\r\n                });\r\n                if (item === selected) {\r\n                    div.className += \" selected\";\r\n                }\r\n                fragment.appendChild(div);\r\n            }\r\n        });\r\n        container.appendChild(fragment);\r\n        if (items.length < 1 && strict) {\r\n            if (settings.emptyMsg) {\r\n                const empty = doc.createElement(\"div\");\r\n                empty.className = \"empty\";\r\n                empty.textContent = settings.emptyMsg;\r\n                container.appendChild(empty);\r\n                selected = undefined;\r\n            } else {\r\n                clear();\r\n                return;\r\n            }\r\n        }\r\n\r\n        attach();\r\n        updatePosition();\r\n\r\n        updateScroll();\r\n    }\r\n\r\n    function updateIfDisplayed(): void {\r\n        if (containerDisplayed()) {\r\n            update();\r\n        }\r\n    }\r\n\r\n    function resizeEventHandler(): void {\r\n        updateIfDisplayed();\r\n    }\r\n\r\n    function scrollEventHandler(e: Event): void {\r\n        if (e.target !== container) {\r\n            updateIfDisplayed();\r\n        } else {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    function keyupEventHandler(ev: KeyboardEvent): void {\r\n        const keyCode = ev.which || ev.keyCode || 0;\r\n\r\n        const ignore = [Keys.Up, Keys.Enter, Keys.Esc, Keys.Right, Keys.Left, Keys.Shift, Keys.Ctrl, Keys.Alt, Keys.CapsLock, Keys.WindowsKey, Keys.Tab];\r\n        for (const key of ignore) {\r\n            if (keyCode === key) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        // the down key is used to open autocomplete\r\n        if (keyCode === Keys.Down && containerDisplayed()) {\r\n            return;\r\n        }\r\n\r\n        startFetch(EventTrigger.Keyboard);\r\n    }\r\n\r\n    /**\r\n     * Automatically move scroll bar if selected item is not visible\r\n     */\r\n\r\n    function updateScroll(): void {\r\n        const elements = container.getElementsByClassName(\"selected\");\r\n        if (elements.length > 0) {\r\n            let element = elements[0] as HTMLDivElement;\r\n\r\n            // make group visible\r\n            const previous = element.previousElementSibling as HTMLDivElement;\r\n            if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\r\n                element = previous;\r\n            }\r\n\r\n            if (element.offsetTop < container.scrollTop) {\r\n                container.scrollTop = element.offsetTop;\r\n            } else {\r\n                const selectBottom = element.offsetTop + element.offsetHeight;\r\n                const containerBottom = container.scrollTop + container.offsetHeight;\r\n                if (selectBottom > containerBottom) {\r\n                    container.scrollTop += selectBottom - containerBottom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select the previous item in suggestions\r\n     */\r\n\r\n    function selectPrev(): void {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        } else {\r\n            if (selected === items[0] || selected === undefined) {\r\n                selected = items[items.length - 1];\r\n            } else {\r\n                for (let i = items.length - 1; i > 0; i--) {\r\n                    if (selected === items[i] || i === 1) {\r\n                        selected = items[i - 1];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select the next item in suggestions\r\n     */\r\n\r\n    function selectNext(): void {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        if (!selected || selected === items[items.length - 1]) {\r\n            selected = items[0];\r\n            return;\r\n        }\r\n        for (let i = 0; i < (items.length - 1); i++) {\r\n            if (selected === items[i]) {\r\n                selected = items[i + 1];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function keydownEventHandler(ev: KeyboardEvent): void {\r\n        const keyCode = ev.which || ev.keyCode || 0;\r\n\r\n        if (keyCode === Keys.Up || keyCode === Keys.Down || keyCode === Keys.Esc) {\r\n            const containerIsDisplayed = containerDisplayed();\r\n\r\n            if (keyCode === Keys.Esc) {\r\n                settings.onSelect(undefined, input, ev);\r\n                clear();\r\n            } else {\r\n                if (!containerDisplayed || items.length < 1) {\r\n                    return;\r\n                }\r\n                keyCode === Keys.Up\r\n                    ? selectPrev()\r\n                    : selectNext();\r\n                update();\r\n            }\r\n\r\n            ev.preventDefault();\r\n            if (containerIsDisplayed) {\r\n                ev.stopPropagation();\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (keyCode === Keys.Enter || keyCode === Keys.Tab) {\r\n            if (strict) {\r\n                settings.onSelect(selected, input, ev);\r\n                clear();\r\n            }\r\n            if (!strict) {\r\n                const freeTextSelect = {label: input.value} as T;\r\n                if (!selected) {\r\n                    if (onFreeTextSelect) {\r\n                        onFreeTextSelect(freeTextSelect, input);\r\n                    }\r\n                    settings.onSelect(freeTextSelect, input, ev);\r\n                } else {\r\n                    settings.onSelect(selected, input, ev);\r\n                }\r\n                clear();\r\n            }\r\n        }\r\n    }\r\n\r\n    function focusEventHandler(): void {\r\n        if (showOnFocus) {\r\n            startFetch(EventTrigger.Focus);\r\n        }\r\n    }\r\n\r\n    function startFetch(trigger: EventTrigger) {\r\n        // if multiple keys were pressed, before we get update from server,\r\n        // this may cause redrawing our autocomplete multiple times after the last key press.\r\n        // to avoid this, the number of times keyboard was pressed will be\r\n        // saved and checked before redraw our autocomplete box.\r\n        const savedKeypressCounter = ++keypressCounter;\r\n\r\n        const val = input.value;\r\n        if (val.length >= minLen || trigger === EventTrigger.Focus) {\r\n            clearDebounceTimer();\r\n            debounceTimer = window.setTimeout(function (): void {\r\n                settings.fetch(val, function (elements: T[] | false): void {\r\n                    if (keypressCounter === savedKeypressCounter && elements) {\r\n                        items = elements;\r\n                        inputValue = val;\r\n                        selected = items.length > 0 && autoselectfirst ? items[0] : undefined;\r\n                        update();\r\n                    }\r\n                }, EventTrigger.Keyboard);\r\n            }, trigger === EventTrigger.Keyboard ? debounceWaitMs : 0);\r\n        } else {\r\n            clear();\r\n        }\r\n    }\r\n\r\n    function blurEventHandler(): void {\r\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\r\n        setTimeout(() => {\r\n            if (doc.activeElement !== input) {\r\n                clear();\r\n            }\r\n        }, 200);\r\n    }\r\n\r\n    /**\r\n     * This function will remove DOM elements and clear event handlers\r\n     */\r\n\r\n    function destroy(): void {\r\n        input.removeEventListener(\"focus\", focusEventHandler);\r\n        input.removeEventListener(\"keydown\", keydownEventHandler);\r\n        input.removeEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\r\n        input.removeEventListener(\"blur\", blurEventHandler);\r\n        doc.removeEventListener(\"resize\", resizeEventHandler);\r\n        doc.removeEventListener(\"scroll\", scrollEventHandler, true);\r\n        clearDebounceTimer();\r\n        clear();\r\n\r\n        // prevent the update call if there are pending AJAX requests\r\n        keypressCounter++;\r\n    }\r\n\r\n    // setup event handlers\r\n    input.addEventListener(\"keydown\", keydownEventHandler);\r\n    input.addEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\r\n    input.addEventListener(\"blur\", blurEventHandler);\r\n    input.addEventListener(\"focus\", focusEventHandler);\r\n    doc.addEventListener(\"resize\", resizeEventHandler);\r\n    doc.addEventListener(\"scroll\", scrollEventHandler, true);\r\n\r\n    return {\r\n        destroy\r\n    };\r\n}\r\n","import {\r\n    Autowired,\r\n    GridOptionsWrapper,\r\n    IAfterGuiAttachedParams,\r\n    ICellEditorComp,\r\n    ICellEditorParams,\r\n    PopupComponent,\r\n    SuppressKeyboardEventParams\r\n} from '@ag-grid-community/core';\r\n\r\nimport './ag-grid-autocomplete-editor.scss';\r\n// This import must be done with require because of TypeScript transpiler problems with export default\r\nimport autocomplete, {AutocompleteItem, EventTrigger} from './autocompleter/autocomplete';\r\n\r\nconst KEY_BACKSPACE = 8;\r\nconst KEY_DELETE = 46;\r\nconst KEY_ENTER = 13;\r\nconst KEY_TAB = 9;\r\nconst KEY_UP = 38;\r\nconst KEY_DOWN = 40;\r\n\r\nexport interface DataFormat extends AutocompleteItem {\r\n    value: number | string;\r\n    label: string;\r\n    group?: string;\r\n}\r\n\r\nexport type AutocompleteClient = DataFormat & AutocompleteItem;\r\n\r\ninterface IDefaultAutocompleterSettings<T extends AutocompleteItem> {\r\n    render: (cellEditor: AutocompleteSelectCellEditor, item: T, currentValue: string) => HTMLDivElement | undefined;\r\n    renderGroup: (cellEditor: AutocompleteSelectCellEditor, name: string, currentValue: string) => HTMLDivElement | undefined;\r\n    className: string;\r\n    minLength: number;\r\n    emptyMsg: string;\r\n    strict: boolean;\r\n    autoselectfirst: boolean;\r\n    onFreeTextSelect: (cellEditor: AutocompleteSelectCellEditor, item: T, input: HTMLInputElement) => void;\r\n    onSelect: (cellEditor: AutocompleteSelectCellEditor, item: T | undefined, input: HTMLInputElement) => void;\r\n    fetch: (cellEditor: AutocompleteSelectCellEditor, text: string, update: (items: T[] | false) => void, trigger?: EventTrigger) => void;\r\n    debounceWaitMs: number;\r\n    showOnFocus: boolean;\r\n    customize: (cellEditor: AutocompleteSelectCellEditor, input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\r\n}\r\n\r\nexport interface IAutocompleterSettings<T extends AutocompleteItem> {\r\n    render?: (cellEditor: AutocompleteSelectCellEditor, item: T, currentValue: string) => HTMLDivElement | undefined;\r\n    renderGroup?: (cellEditor: AutocompleteSelectCellEditor, name: string, currentValue: string) => HTMLDivElement | undefined;\r\n    className?: string;\r\n    minLength?: number;\r\n    emptyMsg?: string;\r\n    strict?: boolean;\r\n    autoselectfirst?: boolean;\r\n    onFreeTextSelect?: (cellEditor: AutocompleteSelectCellEditor, item: T, input: HTMLInputElement) => void;\r\n    onSelect?: (cellEditor: AutocompleteSelectCellEditor, item: T | undefined, input: HTMLInputElement) => void;\r\n    fetch?: (cellEditor: AutocompleteSelectCellEditor, text: string, update: (items: T[] | false) => void, trigger?: EventTrigger) => void;\r\n    debounceWaitMs?: number;\r\n    customize?: (cellEditor: AutocompleteSelectCellEditor, input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\r\n}\r\n\r\nexport interface IAutocompleteSelectCellEditorParams extends ICellEditorParams {\r\n    autocomplete?: IAutocompleterSettings<AutocompleteClient>;\r\n    selectData: Array<DataFormat> | ((params: IAutocompleteSelectCellEditorParams) => Array<DataFormat>);\r\n    placeholder?: string;\r\n    required?: boolean;\r\n}\r\n\r\nexport class AutocompleteSelectCellEditor extends PopupComponent implements ICellEditorComp {\r\n    public currentItem?: DataFormat;\r\n    private focusAfterAttached: boolean = false;\r\n    private readonly eInput: HTMLInputElement;\r\n    private autocompleter?: any;\r\n    private required: boolean = false;\r\n    private stopEditing?: (cancel?: boolean) => void;\r\n\r\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper?: GridOptionsWrapper;\r\n\r\n    constructor() {\r\n        super('<div class=\"ag-wrapper ag-input-wrapper ag-text-field-input-wrapper ag-cell-editor-autocomplete-wrapper\" style=\"padding: 0 !important;\"><input class=\"ag-input-field-input ag-text-field-input ag-cell-editor-autocomplete-input\" type=\"text\"/></div>');\r\n        this.eInput = this.getGui().querySelector('input') as HTMLInputElement;\r\n        if (this.currentItem) {\r\n            this.eInput.value = this.currentItem.label || this.currentItem.value as string;\r\n        }\r\n    }\r\n\r\n    private static suppressKeyboardEvent(params: SuppressKeyboardEventParams): boolean {\r\n        let keyCode = params.event.keyCode;\r\n        return params.editing && (keyCode === KEY_UP || keyCode === KEY_DOWN || keyCode === KEY_ENTER || keyCode === KEY_TAB);\r\n    }\r\n\r\n    private static getStartValue(params: IAutocompleteSelectCellEditorParams) {\r\n        const keyPressBackspaceOrDelete = params.keyPress === KEY_BACKSPACE || params.keyPress === KEY_DELETE;\r\n        if (keyPressBackspaceOrDelete) {\r\n            return '';\r\n        } else if (params.charPress) {\r\n            return params.charPress;\r\n        }\r\n        return params.formatValue(params.value);\r\n    }\r\n\r\n    public init(params: IAutocompleteSelectCellEditorParams) {\r\n        this.stopEditing = params.stopEditing;\r\n        const defaultSettings: IDefaultAutocompleterSettings<AutocompleteClient> = {\r\n            showOnFocus: false,\r\n            render: function (cellEditor: AutocompleteSelectCellEditor, item: AutocompleteClient, value) {\r\n                let itemElement = document.createElement(\"div\");\r\n                let escapedValue = (value ?? '').replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n                let regex = new RegExp(escapedValue, 'gi');\r\n                let fieldItem = document.createElement('span');\r\n                fieldItem.innerHTML = item.label.replace(regex, function (match: string) {\r\n                    return \"<strong>\" + match + \"</strong>\"\r\n                });\r\n                itemElement.appendChild(fieldItem);\r\n                cellEditor.addManagedListener(itemElement, 'mousedown', (event: MouseEvent) => {\r\n                    cellEditor.currentItem = item;\r\n                    event.stopPropagation();\r\n                });\r\n                return itemElement;\r\n            },\r\n            renderGroup: function (cellEditor, name) {\r\n                let div = document.createElement('div');\r\n                div.textContent = name;\r\n                div.className = \"group\";\r\n                return div;\r\n            },\r\n            className: 'ag-cell-editor-autocomplete',\r\n            minLength: 1,\r\n            emptyMsg: \"None\",\r\n            strict: true,\r\n            autoselectfirst: true,\r\n            onFreeTextSelect: function () {\r\n            },\r\n            onSelect: function (cellEditor, item: AutocompleteClient | undefined) {\r\n                cellEditor.currentItem = item;\r\n            },\r\n            fetch: (cellEditor, text, callback) => {\r\n                let items = this.getSelectData(params);\r\n                let match = text.toLowerCase() || cellEditor.eInput.value.toLowerCase();\r\n                callback(items.filter(function (n) {\r\n                    return n.label.toLowerCase().indexOf(match) !== -1;\r\n                }));\r\n            },\r\n            debounceWaitMs: 200,\r\n            customize: function (cellEditor, input, inputRect, container, maxHeight) {\r\n                if (maxHeight < 100) {\r\n                    container.style.top = \"10px\";\r\n                    container.style.bottom = (window.innerHeight - inputRect.bottom + input.offsetHeight) + \"px\";\r\n                    container.style.maxHeight = \"140px\";\r\n                }\r\n            }\r\n        };\r\n        this.focusAfterAttached = params.cellStartedEdit;\r\n\r\n        this.eInput.placeholder = params.placeholder || '';\r\n        this.eInput.value = AutocompleteSelectCellEditor.getStartValue(params);\r\n\r\n        const autocompleteParams = {...defaultSettings, ...params.autocomplete};\r\n\r\n        this.autocompleter = autocomplete({\r\n            input: this.eInput,\r\n            render: (item: AutocompleteClient, currentValue: string) => {\r\n                if (autocompleteParams.render) {\r\n                    return autocompleteParams.render(this, item, currentValue);\r\n                }\r\n                return defaultSettings.render(this, item, currentValue);\r\n            },\r\n            renderGroup: (name: string, currentValue: string) => {\r\n                if (autocompleteParams.renderGroup) {\r\n                    return autocompleteParams.renderGroup(this, name, currentValue);\r\n                }\r\n                return defaultSettings.renderGroup(this, name, currentValue);\r\n            },\r\n            className: autocompleteParams.className || defaultSettings.className,\r\n            minLength: autocompleteParams.minLength !== undefined ? autocompleteParams.minLength : defaultSettings.minLength,\r\n            emptyMsg: autocompleteParams.emptyMsg || defaultSettings.emptyMsg,\r\n            strict: autocompleteParams.strict,\r\n            autoselectfirst: autocompleteParams.autoselectfirst,\r\n            showOnFocus: autocompleteParams.showOnFocus,\r\n            onFreeTextSelect: (item: AutocompleteClient, input: HTMLInputElement) => {\r\n                if (autocompleteParams.onFreeTextSelect) {\r\n                    return autocompleteParams.onFreeTextSelect(this, item, input);\r\n                }\r\n                return defaultSettings.onFreeTextSelect(this, item, input);\r\n            },\r\n            onSelect: (item: AutocompleteClient | undefined, input: HTMLInputElement, event: KeyboardEvent | MouseEvent) => {\r\n                let result: any;\r\n                if (autocompleteParams.onSelect) {\r\n                    result = autocompleteParams.onSelect(this, item, input);\r\n                    if (event instanceof KeyboardEvent) {\r\n                        this.handleTabEvent(event);\r\n                    } else {\r\n                        this.destroy();\r\n                    }\r\n                    return result;\r\n                }\r\n                result = defaultSettings.onSelect(this, item, input);\r\n                if (event instanceof KeyboardEvent) {\r\n                    this.handleTabEvent(event);\r\n                } else {\r\n                    this.destroy();\r\n                }\r\n                return result;\r\n            },\r\n            fetch: (text: string, update: (items: AutocompleteClient[] | false) => void, trigger: EventTrigger) => {\r\n                if (autocompleteParams.fetch) {\r\n                    return autocompleteParams.fetch(this, text, update, trigger)\r\n                }\r\n                return defaultSettings.fetch(this, text, update, trigger);\r\n            },\r\n            debounceWaitMs: autocompleteParams.debounceWaitMs || defaultSettings.debounceWaitMs,\r\n            customize: (input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => {\r\n                if (autocompleteParams.customize) {\r\n                    return autocompleteParams.customize(this, input, inputRect, container, maxHeight);\r\n                }\r\n                return defaultSettings.customize(this, input, inputRect, container, maxHeight);\r\n            }\r\n        });\r\n        if (params.required) {\r\n            this.required = true;\r\n        }\r\n        if (!params.colDef.suppressKeyboardEvent) {\r\n            params.colDef.suppressKeyboardEvent = AutocompleteSelectCellEditor.suppressKeyboardEvent;\r\n        }\r\n    }\r\n\r\n    handleTabEvent(event: KeyboardEvent) {\r\n        const keyCode = event.which || event.keyCode || 0;\r\n        if (keyCode === KEY_TAB && this.gridOptionsWrapper) {\r\n            if (event.shiftKey) {\r\n                this.gridOptionsWrapper.getApi()!.tabToPreviousCell();\r\n            } else {\r\n                this.gridOptionsWrapper.getApi()!.tabToNextCell();\r\n            }\r\n        } else {\r\n            this.destroy();\r\n        }\r\n    }\r\n\r\n    afterGuiAttached(params?: IAfterGuiAttachedParams): void {\r\n        if (!this.focusAfterAttached) {\r\n            return;\r\n        }\r\n\r\n        const eInput = this.eInput;\r\n        eInput.focus();\r\n        eInput.select();\r\n        // when we started editing, we want the caret at the end, not the start.\r\n        // this comes into play in two scenarios: a) when user hits F2 and b)\r\n        // when user hits a printable character, then on IE (and only IE) the caret\r\n        // was placed after the first character, thus 'apply' would end up as 'pplea'\r\n        const length = eInput.value ? eInput.value.length : 0;\r\n        if (length > 0) {\r\n            eInput.setSelectionRange(length, length);\r\n        }\r\n    }\r\n\r\n    focusIn(): void {\r\n        this.eInput.focus();\r\n        this.eInput.select();\r\n    }\r\n\r\n    focusOut(): void {\r\n        this.eInput.blur();\r\n        this.autocompleter.destroy();\r\n    }\r\n\r\n    destroy(): void {\r\n        this.focusOut();\r\n        if (this.stopEditing) {\r\n            this.stopEditing();\r\n        }\r\n    }\r\n\r\n    getValue(): DataFormat | undefined {\r\n        return this.currentItem;\r\n    }\r\n\r\n    isCancelAfterEnd(): boolean {\r\n        if (this.required) {\r\n            return !this.currentItem;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isCancelBeforeStart(): boolean {\r\n        return false;\r\n    }\r\n\r\n    isPopup(): boolean {\r\n        return false;\r\n    }\r\n\r\n    getSelectData(params: IAutocompleteSelectCellEditorParams): Array<DataFormat> {\r\n        if (typeof params.selectData === 'function') {\r\n            return params.selectData(params);\r\n        }\r\n\r\n        if (Array.isArray(params.selectData)) {\r\n            return params.selectData as Array<DataFormat>;\r\n        }\r\n\r\n        return [];\r\n    }\r\n}\r\n"],"sourceRoot":""}